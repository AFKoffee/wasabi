%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[sigplan,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[sigplan]{acmart}\settopmatter{}


%% Conference information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmConference[PL'18]{ACM SIGPLAN Conference on Programming Languages}{January 01--03, 2018}{New York, NY, USA}
\acmYear{2018}
\acmISBN{} % \acmISBN{978-x-xxxx-xxxx-x/YY/MM}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%\citestyle{acmauthoryear}  %% For author/year citations
%\citestyle{acmnumeric}     %% For numeric citations
%\setcitestyle{nosort}      %% With 'acmnumeric', to disable automatic
                            %% sorting of references within a single citation;
                            %% e.g., \cite{Smith99,Carpenter05,Baker12}
                            %% rendered as [14,5,2] rather than [2,5,14].
%\setcitesyle{nocompress}   %% With 'acmnumeric', to disable automatic
                            %% compression of sequential references within a
                            %% single citation;
                            %% e.g., \cite{Baker12,Baker14,Baker16}
                            %% rendered as [2,3,4] rather than [2-4].


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from traditional SIGPLAN
%% proceedings format to PACMPL format must update the
%% '\documentclass' and topmatter commands above; see
%% 'acmart-pacmpl-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

\usepackage{csquotes}

\newcommand{\citeTodo}{[\textcolor{red}{\bfseries?}]}

\usepackage{enumitem}

\newcommand{\name}{Wasabi}

\hyphenation{Web-As-sem-bly}

\usepackage{cleveref}

\newcommand{\todo}[1]{\textcolor{red}{#1}}

\begin{document}

%% Title information
\title{\name: WebAssembly\\Analysis and Binary Instrumentation}         %% [Short Title] is optional;
                                        %% when present, will be used in
                                        %% header instead of Full Title.
%\titlenote{with title note}             %% \titlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'
%\subtitle{Powerful, Robust, Easy -- Pick Three.}                     %% \subtitle is optional
%\subtitlenote{with subtitle note}       %% \subtitlenote is optional;
                                        %% can be repeated if necessary;
                                        %% contents suppressed with 'anonymous'


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

%% Author with single affiliation.
\author{First1 Last1}
\authornote{with author1 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position1}
  \department{Department1}              %% \department is recommended
  \institution{Institution1}            %% \institution is required
  \streetaddress{Street1 Address1}
  \city{City1}
  \state{State1}
  \postcode{Post-Code1}
  \country{Country1}                    %% \country is recommended
}
\email{first1.last1@inst1.edu}          %% \email is recommended

%% Author with two affiliations and emails.
\author{First2 Last2}
\authornote{with author2 note}          %% \authornote is optional;
                                        %% can be repeated if necessary
\orcid{nnnn-nnnn-nnnn-nnnn}             %% \orcid is optional
\affiliation{
  \position{Position2a}
  \department{Department2a}             %% \department is recommended
  \institution{Institution2a}           %% \institution is required
  \streetaddress{Street2a Address2a}
  \city{City2a}
  \state{State2a}
  \postcode{Post-Code2a}
  \country{Country2a}                   %% \country is recommended
}
\email{first2.last2@inst2a.com}         %% \email is recommended
\affiliation{
  \position{Position2b}
  \department{Department2b}             %% \department is recommended
  \institution{Institution2b}           %% \institution is required
  \streetaddress{Street3b Address2b}
  \city{City2b}
  \state{State2b}
  \postcode{Post-Code2b}
  \country{Country2b}                   %% \country is recommended
}
\email{first2.last2@inst2b.org}         %% \email is recommended


%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
\begin{abstract}
\vspace*{9.8cm}
\end{abstract}


%% 2012 ACM Computing Classification System (CSS) concepts
%% Generate at 'http://dl.acm.org/ccs/ccs.cfm'.
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10011006.10011008</concept_id>
<concept_desc>Software and its engineering~General programming languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003456.10003457.10003521.10003525</concept_id>
<concept_desc>Social and professional topics~History of programming languages</concept_desc>
<concept_significance>300</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~General programming languages}
\ccsdesc[300]{Social and professional topics~History of programming languages}
%% End of generated code


%% Keywords
%% comma separated list
\keywords{WebAssembly, dynamic analysis, binary instrumentation}  %% \keywords are mandatory in final camera-ready submission


%% \maketitle
%% Note: \maketitle command must come after title commands, author
%% commands, abstract environment, Computing Classification System
%% environment and commands, and keywords command.
\maketitle


\section{Introduction}

%% Context: Set the stage, relate to reader's situation

% Wasm is new and is here to stay
Until last year, the only widely supported programming language for the Web was JavaScript. Now that \emph{WebAssembly} (or \emph{Wasm} for short)~\cite{Haas:2017:BWU:3062341.3062363, WasmWebsite} has reached cross-browser consensus~\cite{WasmConsensus}, developers finally have a fast, yet safe and portable alternative for client-side execution. Wasm is also available in Node.js~\cite{NodejsWebsite}, a widely used server-side runtime, and is being considered for the next version of the Ethereum distributed virtual machine~\cite{EthereumWasm}. With all of these uses, WebAssembly will be a ubiquitous and highly important virtual instruction set for years to come.

% Wasm unique points and implications why dynamic analysis is important
The central properties of WebAssembly are as much reason for its attractiveness as they are challenges for users: 
\begin{enumerate}[leftmargin=\parindent]
	\item WebAssembly is a binary instruction format, which makes it compact (thus, quick to send over the network) and fast to decode (unlike JavaScript, where parsing can be a major bottleneck~\citeTodo). Unfortunately, this is also the final nail in the coffin of the \enquote{view source mentality} of the Web. Developers are more reliant on tooling than ever to understand complex web applications.
	
	\item Unlike previous attempts like ActiveX, Native Client~\citeTodo, or asm.js~\citeTodo, WebAssembly is truly portable across all major browsers, which is an impressive social achievement on top of the technical one. The multitude of actors makes it crucial to not rely on a single vendor for WebAssembly tooling support. If just because of their users, developers need to test on and work with any of the competing WebAssembly implementations.
	 
	\item WebAssembly's core use-case is as a compilation target for systems programming languages like C, C++, or Rust. The low-level control over memory layout and allocations, and the close mapping to native instructions enables much of its speed, but also comes with great responsibility. Developers on x86 are used to dynamic analysis tools built on top of, e.g., Valgrind~\citeTodo{} or Pin~\citeTodo{} to find bugs or fix performance problems, but no such platform exists for WebAssembly so far.
\end{enumerate}
%new possibilities, but also new challenges:
%- (portable; good: works everywhere, bad: need tools in all of these browsers) Supported across all major browsers (Chrome, Firefox, Safari, Edge), on PCs and mobile devices
%- (binary; good: compact and fast, bad: no view source anymore, more low-level, less accessible -> we need tools more than ever!) While the binary format makes WebAssembly programs compact and quick to decode (unlike JavaScript, where parsing can take a substantial amount of the time to first meaningful interaction), it is also the final nail in the coffin for the "view source" mentality of the web.
%- Compilation target for systems languages like C, C++, and Rust; people are used to great analysis tools like Memcheck or UBSan, but currently there are no counterparts for this in Wasm

\noindent \todo{order/extent of the following parts not good yet}

\noindent \todo{wording: platform vs framework vs toolkit}

In this paper, we present \emph{Wasabi}, a framework for \underline{W}eb\-\underline{As}sembly dynamic \underline{a}nalysis through \underline{b}inary \underline{i}nstrumentation. As for any dynamic analysis, our design has to make trade-offs along several broad dimensions:

\begin{itemize}[leftmargin=\parindent, label=$\circ$]
	\item \emph{Specialized vs. generic}: Many dynamic analyses have been written that solve one particular task, such as memory checking (Purify~\citeTodo) or taint analysis (TaintDroid~\citeTodo), and are specifically optimized for it. Especially due to the young age of Wasm, we instead aim to solve the general case first and want to enable others writing many of these specific instances of dynamic analyses on top of our framework. This principle has been tremendously successful with frameworks such as Pin, DynamoRIO, Valgrind, \todo{Java dyn. analysis framework?}, or Jalangi.

	\item \emph{Heavy- vs. lightweight}: Lightweight dynamic analysis (like \texttt{strace} or \texttt{ltrace}~\citeTodo) incurs minimal overhead, but does so at the cost of observing only a small subset of the program execution, typically at the interface to the outside world, e.g., syscalls to the operating system or library function calls. On the other end of the spectrum stands full emulation (TODO~\citeTodo), which can observe any behavior. It is not only slow, but also very hard to implement correctly, i.e., such that the emulated behavior matches the real execution. We choose (binary) instrumentation, which hits a sweet spot between these extremes. No full Wasm VM has to be implemented or modified, but any instruction of the program can be monitored.
	
	\item \emph{Static vs. dynamic instrumentation}: In x86, variable length instructions and self-modifying code make reliable static disassembly almost impossible, necessitating dynamic instrumentation in Valgrind~\citeTodo, DynamoRIO~\citeTodo, and Pin~\citeTodo. Thankfully, WebAssembly is well designed to be decoded and verified statically, allowing us to reliably instrument the whole program before execution. For developer convenience, Wasabi does not have to be run externally on Wasm files before execution. Simply adding a single file to a website or Node.js project is sufficient to transparently instrument all Wasm parts of an application with \name.
	
	\item \emph{Interaction between application and analysis}: The two contrasting choices are to inline the analysis into the original application or to keep the analysis code separate and call-out to it during execution. We chose the latter approach for several reasons: External analyses can be implemented in JavaScript, which is a convenient high-level language; using the callback model requires only minimal modification of the original program; and not having to interleave application and analysis avoids the problem that WebAssembly allows only a single linear memory per program.
%	
%	 it avoids having to interleave WebAssembly memory of the application with memory used by the analysis thus making the instrumentation more robust
%	
%	also because WebAssembly currently allows only a single linear memory for a program, making it difficult to reliably interleave memory used by the original application with memory used by the analysis code. Instead, we only insert callbacks to imported analysis hooks which also has the benefit of modifying the original program in a very confined way, making the instrumentation robust.
%	
%	Valgrind, for example, transforms the application into an intermediate representation (IR), inserts the analysis code into this IR, and then fully resynthesizes the instrumented binary. While this is claimed to offer less overhead to callback-based analysis frameworks (e.g., Jalangi), it is also harder to implement reliably, especially when the original application's memory is modified. In WebAssembly, only one linear memory is permitted per program, which makes it hard to interleave application and analysis code into one output program. Our framework thus uses callbacks, where the actual analysis is performed.
%	
%	modification/merging/inlining
%	callbacks
%	in which language should it be written	
%	Jalangi~\cite{Sen:2013:JSR:2491411.2491447}
%	
%	possible (no double memory in Wasm)
%	performance (no interop to pay)
%	usability (JS for analyses is nice)
\end{itemize}

\noindent
Apart from being the first dynamic analysis framework for WebAssembly whatsoever, we believe our decisions in the design space give rise to three key characteristics of Wasabi:

\begin{itemize}[leftmargin=\parindent, label=$\circ$]
	\item \emph{Powerful}: Dynamic analyses based on Wasabi can observe all inputs and outputs to any instruction in the programm. 64 bit integers, even though not natively supported by JavaScript, are handled in conjunction with a runtime component. Wasabi is powerful enough to write heavy-weight dynamic analyses on top of it, such as taint analysis or memory checking.
	
	\item \emph{Robust}: The instrumentation inserted into the program is minimal and does not interfere with the execution of the original instructions. In particular, memory is not altered, only calls and their arguments are inserted, and with the help of standard WebAssembly type checking and verification we can statically ensure instrumented binaries are valid.
	
	\item \emph{Easy to use}: Many analysis frameworks for low-level languages require a complicated setup or special execution environments. Often, also the analyses themselves have to deal with intricate details of the underlying binary that are orthogonal to the problems the user of such frameworks wants to solve. Wasabi works with any browser (or Node.js) that has WebAssembly support, instrumentation is enabled by including a single file, and analysis code can be written conveniently in JavaScript, using a high-level API that hides irrelevant details of WebAssembly.	
\end{itemize}

\paragraph{Contributions} After some background on WebAssembly in \Cref{sec:background}, the rest of the paper presents our key points:

\begin{itemize}[leftmargin=\parindent]
	\item We systematically explore the design space for dynamic analysis of WebAssembly programs and explain the trade-offs for every decision (\Cref{sec:design}).
	\item We present \emph{\name}, the first dynamic analysis framework for WebAssembly, built on top of binary instrumentation (\Cref{sec:wasabi}). Wasabi is powerful, robust, easy to use, and available to the public under a permissive open-source license at \url{https://github.com/danleh/wasabi}.
	\item We implement several dynamic analyses (coverage, taint analysis, memory checking) on top of Wasabi to demonstrate its generality and usability in practice (\Cref{sec:examples}).
	\item We perform experiments to assess Wasabi's code size, runtime, and memory overhead as well as its robustness, i.e., the faithfulness to the unaltered execution (\Cref{sec:experiments}).
\end{itemize}

%good: anything CPU and/or memory allocation intensive

%Wasm: new performant low-level/binary stack-based VM, client side web only had JavaScript and several not or no longer widely supported extensions such as ActiveX, Java, Flash, NaCl and PNaCl, asm.js.

%Dynamic Analysis: very generic term, powerful techniques fall into this category, used 

% Gap: What is missing, "the problem"
%True end of the "view-source" mentality (already severely limited with bundlers, minification, obfuscation)
%Very early: static analysis, like wasm explorer/wasm Studio, wasm code size profiler
%No dynamic wasm tooling at all (to the best of our knowledge)

% Innovation: What do we do and why does it solve the problem

%\paragraph{Name of the Tool}
%there are already 2 programs with name Wasabi, alternative: Wasambi?  sounds similar to Jalangi ;)
%
%make searchable: "wasabi toolkit"?
%
%domains: (wasambi|wasabi-toolkit|wasabi-framework).(de|com|org|eu) are free
%
%crates.io names are both free: wasabi and wasambi

%\paragraph{Pros of our approach}
%Some of the robustness of our approach can be attributed to the great design of WebAssembly (e.g., reliable disassembly, unlike for x86), but others have involved careful design of our approach (no memory modification) and necessitated solving unique challenges (monomorphization of instrumentation hooks)
%
%Full coverage: every instruction can be observed
%
%i64 handling
%
%memory is never touched (\textrightarrow robustness), only instructions inserted are operating on stack/locals + calls
%
%(TODO) could on-the-fly instrument by compiling instrumentation itself to WASM
%
%no need to modify browser engine: works with every vendor, easier to maintain

%\paragraph{Contributions}
%
%- tooling is an "enabling technology" for many more applications: performance, security, correctness
%- wasm is young, not tooling yet!
%- first binary instrumentation framework for Wasm
%- first dynamic analysis framework for Wasm whatsoever
%- heavy-weight, but very powerful and generic (unlike TaintAssembly)
%- see presentations:
%	* Complete, powerful
%	* Robust, correct
%	* Easy-to-use
%- technical: 
%	* "on-demand monomorphization", we create only the variants that actually exist in the binary (compare with all possible combinations that we would otherwise have to create)
%	* no memory changes
%	* convenient, high-level API
%		- mapping labels -> instruction locations
%		- binary/unary hooks are generic over every instruction
%		- different types handled, especially i64
%- meta execution (but lets do it in javascript for now...)
%		
%\paragraph{Open Questions}
%- how is multithreading in C/C++ actually compiled to Wasm?
%	* it cant with stable: fails with "unresolved symbol pthreads"
%	* on nightly: web workers + SAB + added WASM atomic load/store instructions
%
%- how are we different from Jalangi?

\newpage
\section{Background}
\label{sec:background}

why Wasm is interesting

compilation target for languages on the client (a first since JS!)

new Ethereum VM bytecode

running example: WAST format, WASM bytecode

\newpage
\section{Design Space and Trade-Offs}
\label{sec:design}

streaming instrumentation

parallel instrumentation

static vs dynamic (JIT) instrumentation: dynamic not necessary since WASM can be reliably disassembled (unlike x86)

in-engine vs externally

instrumentation language: Rust -> WASM

analysis language: JS

\newpage
\section {Wasabi}
\label{sec:wasabi}

\subsection{Overview}
\label{sec:overview}

layered architecture

\subsection{Static Binary Instrumentation}
\label{sec:instrumentation}

\subsection{Runtime}
\label{sec:runtime}

\subsection{Using the Analysis Interface}
\label{sec:interface}

\newpage
\section{Example Dynamic Analyses}
\label{sec:examples}

Classical Dynamic Analysis Triplet: Correctness, Security, Performance
corresponding analyses to implement: memory checking tool (cf. Dr. Memory), taint analysis, profiling/coverage

case studies: tools/analyses written on top of \name

stmt, branch coverage

taint analysis

memory profiler, tracer

for security: reverse engineering WASM malware, especially important now that WASM takes away "view source" mentality of the web

idea: reverse engineer coinhive monero miner written in WASM

\newpage
\section{Experimental Evaluation}
\label{sec:experiments}

\subsection{Overhead}
code size

performance: SPEC CPU, Ostrich, vs. TaintAsm, SF4.0 "kernels"?

\subsection{Robustness}
compile wide range of benchmarks/test programs, see if they still work as before

\subsection{Usability and Applications}

"enabling technology", e.g. Jalangi has been used in ... projects, cited ... times

\subsection{Limitations}
- call\_indirect

- mapping labels -> locations

- drop/select

- mutations

\newpage
\section{Related Work}

\subsection{WebAssembly}

WebAssembly \cite{Haas:2017:BWU:3062341.3062363}

\subsection{Binary Instrumentation and Dynamic Analysis}

Jalangi \cite{Sen:2013:JSR:2491411.2491447}

PIN \cite{Luk:2005:PBC:1065010.1065034}

Valgrind \cite{Nethercote:2007:VFH:1250734.1250746}

TaintAssembly \cite{2018arXiv180201050F}

TaintDroid \cite{Enck:2014:TIT:2642648.2619091}

\bibliography{references}

\end{document}

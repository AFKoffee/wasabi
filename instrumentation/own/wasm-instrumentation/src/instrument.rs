use ast::{FunctionType, GlobalType};
use ast::highlevel::{Code, Expr, Function, Instr, Module, VisitExpr};
use ast::highlevel::Instr::*;
use ast::Mutability::*;
use ast::ValType::*;
use ast::highlevel::Memory;
use ast::Limits;
use ast::MemoryType;

// TODO Idea: provide two options of connecting user analysis (i.e., client instrumentation code)
// with the instrumented binary (i.e., the "host" code + hooks + import of callbacks):
// A) "dynamic/late binding": instrument host code once, write many analyses as separate WASM
//    modules. Use the JavaScript/host WASM API to "link" the two together at runtime, i.e.,
//    export analysis functions as JS functions and provide them as import object to the
//    instrumented binary.
//    Possibly suuper slow since we go WASM <-> JS <-> WASM
// B) "static binding": Still build the two modules seperately. But use "wasm linker" and "wasm
//    inliner" to optimize the cross-language boundary away.
//
//    Step 1 WASM linker: Append all contents from the analysis module onto the host binary. Then
//    replace all imported functions (in the host binary) with code from the exported functions
//    of the analysis module IFF their names match.
//    FIXME Problem with linking: only one memory and table section allowed, what to do if two?
//    - for Memory: replace all memory operations (in particular CurrentMemory and GrowMemory) with
//                  own versions, where the second memory is placed at an offset into the same
//                  memory space as the first one.
//    - for Tables: not so easy because of the default label target
//
//    Step 2 inlining (possibly by external tool, WABT?):
//    Trivial inlining: if function body is empty (since most callbacks won't be used by the
//    analysis module), remove the call to the function + setup of function arguments

pub fn instrumentation_module() -> Module {
    let mut module = Module::new();

    module.memories.push(Memory {
        type_: MemoryType(Limits{ initial_size: 10, max_size: None }),
        import: None,
        data: Vec::new(),
        export: None,
    });

    module.memories.push(Memory {
        type_: MemoryType(Limits{ initial_size: 2, max_size: None }),
        import: Some(("bla".into(), "blub".into())),
        data: Vec::new(),
        export: None,
    });

//    module.add_function(FunctionType(vec![I32]))

    module
}

// TODO to be compiled with target = wasm-unknown-unkown
mod analysis_api {
    use ast::{Idx, highlevel::Function, highlevel::Instr};
    use ast::ValType;

    #[derive(Copy, Clone)]
    enum Val {
        I32(i32),
        I64(i64),
        F32(f32),
        F64(f64),
    }

    struct InstructionLocation(Idx<Function>, Idx<Instr>);

    fn call(i: InstructionLocation, target: Idx<Function>) {}
    fn return_(i: InstructionLocation, results: &[Val]) {}

    // function gives the Idx<Function>, implicitly Idx<Instr> == 0
    fn function_begin(function: Idx<Function>, arguments: &[Val]) {}
    fn function_end(function: Idx<Function>, results: &[Val]) {}


    // generated by instrumentation framework, must be regenerated if function signatures of host change
    fn function_begin_i32(function: Idx<Function>, arg0: i32) {
        function_begin(function, &[Val::I32(arg0)]);
    }
    // etc...

//    fn const_(val: Val) {}

}

pub fn identity(_: &mut Module) {}

pub fn add_empty_function(module: &mut Module) {
    module.add_function(
        FunctionType(vec![], vec![]),
        vec![],
        vec![End]);
}

pub fn count_calls(module: &mut Module) {
    let counter = module.add_global(
        GlobalType(I32, Mut),
        vec![I32Const(0), End]);

    let getter = module.add_function(
        FunctionType(vec![], vec![I32]),
        vec![],
        vec![GetGlobal(counter), End]);
    module.function(getter).export = Some("get_counter".into());

    let increment = module.add_function(
        FunctionType(vec![], vec![]),
        vec![],
        vec![
            GetGlobal(counter),
            I32Const(1),
            I32Add,
            SetGlobal(counter),
            End
        ]);

    for (i, function) in module.functions() {
        // ignore the functions we added
        if i != getter && i != increment {
            if let Some(Code { ref mut body, .. }) = function.code {
                VisitExpr::bottom_up(body, &|instrs: &mut Expr| {
                    let mut last_call_instr_idx = 0;
                    while let Some(call_instr_idx) = instrs[last_call_instr_idx..].iter().position(Instr::is_call) {
                        instrs.insert(call_instr_idx, Call(increment));
                        last_call_instr_idx = call_instr_idx + 2;
                    }
                });
            }
        }
    }
}

//// TODO implement actual instrumentations:
//// - call instruction counting
//// - counting which function gets called how often
//// - BB counting
//// ...
